#include "goboard.h"
#include <QDebug>
#include <ctime>

GoBoard::GoBoard(QObject *parent) : QObject(parent), currentColor(1), killedStoneFlag(0), imaginaryKoIndex(-10) { }

GoBoard::~GoBoard() { }

// Идентификация группы - запоминание всех индексов камней текущей группы и количества её дыханий
void GoBoard::identifyGroup(QList<QList<int>> array, const int &positionX, const int &positionY,
                            const int & index, const int & color, int & libertyCounter) {

    // Если выходим за границу доски - прерываем обработку текущей группы
    if (positionX == 0 || positionX == 20 || positionY == 0 || positionY == 20)
        return;

    // Берём значение текущей позиции камня
    int &currentPosition = array[positionX][positionY];

    // Если текущая позиция свободна - увеличиваем счетчик дыханий и отмечаем посещенную
    // позицию
    if (currentPosition == -1)
    {
        currentPosition = -2;
        libertyCounter += 1;
    }

    // Если текущая позиция того же цвета, что и камни группы, значит считаем эту позицию как
    // продолжение этой группы
    if (currentPosition == color) {

        // Отмечаем текущую позицию как посещенную
        currentPosition = -2;

        /*
         * Мемоизация рекурсии - если в одном из четырёх направлений на очередном шаге
         * рекурсии встречается уже запомненный индекс камня в множестве камней группы
         * это значит, что камень уже был посещен рекурсией до этого, а значит и четыре
         * камня, находящиеся в непосредственной близи от него тоже были рекурсивно посещены
         * вместе с ним и тоже учтены в множестве, тогда прерываем выполнение рекурсии
         * на данном шаге. Проблема похожа на рекурсивное вычисление чисел Фибоначчи.
         *
         * При реализации без мемоизации посещенных позиций O(4^n) в худшем случае, где n -
         * кол-во камней в множестве индексов группы. Худший случай - когда вся доска
         * заполнена камнями одного цвета, прилегающими друг к другу.
         *
         * Эффект от улучшения реализации приводит к оценке O(n). При таком улучшении
         * на обработку группы камней в практических условиях требуется около ~0.024119сек.
         * вместо нескольких тысячелетий.
        */
        if (currentGroup.contains(index))
            return;

        // Вносим в множество индексов группы индекс текущей позиции камня
        currentGroup.insert(index);

        // От текущей позиции камня проходим по четырём соседним направлениям (слева, справа,
        // снизу и сверху) для поиска остальных камней группы и подсчёта количества её дыханий
        identifyGroup(array, positionX - 1, positionY, index - 21, color, libertyCounter);
        identifyGroup(array, positionX + 1, positionY, index + 21, color, libertyCounter);
        identifyGroup(array, positionX, positionY + 1, index + 1, color, libertyCounter);
        identifyGroup(array, positionX, positionY - 1, index - 1, color, libertyCounter);

        // Если группа состоит из более чем одного камня - считаем, что над этой группой возможно
        // сделать дамедзумари (вводим отдельно обработку дамедзумари, чтобы отделить эту ситуацию
        // от правила ко)
        if (currentGroup.size() > 1)
            damezumariFlag = 1;
        else
            damezumariFlag = 0;
    }
}

// Функция обнаружения соседних групп камней противоположного цвета
void GoBoard::checkNearestGroup(QList<QList<int>> &array, const int &positionX, const int &positionY,
                                const int &index, const int & color) {

    // Если выходим за границу доски - прерываем обработку текущей группы
    if (positionX == 0 || positionX == 20 || positionY == 0 || positionY == 20)
        return;

    // Если цвет камня на текущей позиции совпадает с цветом камня игрока на данном ходе (группа
    // того же цвета) или цвет равен значению свободной позиции на доске - прерываем просмотр
    // соседних камней от данной позиции, т.к. функция обязательно должна просматривать группы
    // камней другого цвета
    if (color == currentColor || color == -1)
        return;

    // Если камень на текущей позиции не совпадает с цветом камня игрока на данном ходе, проверяем
    // группу исходящую от этого камня (или сам камень, если группа состоит из него одного)
    if (color == !currentColor) {

        // Создаем счетчик дыханий группы и находим, во-первых, саму группу, включающую этот камень
        // противоположного цвета, во-вторых, количество дыханий у всей группы противоположного цвета
        // целиком
        int libertyCounter = 0;
        identifyGroup(array, positionX, positionY, index, !currentColor, libertyCounter);

        // Если количество дыханий равно нулю это означает, что группа противоположного цвета должна
        // быть снята с доски и отнесена к пленным камням
        if (libertyCounter == 0) {

            // Если снимаемая с доски группа противоположного цвета состоит из одного камня, тогда
            // запоминаем предполагаемый индекс позиции для реализации правила ко (это не всегда
            // реальный индекс позиции ко, т.к. снимаемая с доски группа, состоящая из одного камня,
            // не обязательно учавствует в ко-игре, но этот индекс потребуется в дальнейшем для
            // нахождения реального индекса позиции ко)
            if (currentGroup.size() == 1)
                imaginaryKoIndex = index;

            // Обновляем актуальное количество пленных камней
            emit updateCaptiveStones(positionX, positionY, currentGroup.size(), currentColor);

            // Удаляем все камни с доски, взятые из множества индексов камней группы противоположного
            // цвета
            for (QSet<int>::iterator it = currentGroup.begin(); it != currentGroup.end(); it++)
                emit deleteStone(*it);

            // Выставляем флаг, сигнализирующий о снятии с доски группы камней
            killedStoneFlag = 1;

            // Если размер группы равен единице - выставляем флаг, говорящий о том, что группа состоит
            // из одного камня
            if (currentGroup.size() == 1)
                oneStoneFlag = 1;
        }

        // Очищаем множество индексов камней группы противоположного цвета
        currentGroup.clear();
    }
}

// Функция проверки взятия в плен хотя бы одного соседнего камня слева, снизу, сверху или справа от поставленного
bool GoBoard::isNearStonesKilled(QList<QList<int>> & array, const int &positionX, const int &positionY, const int & index, const int & color)
{
    // Инициализируем флаг для определения взятого в плен камня, индексы для прохода по всем четырём направлениям
    // от поставленного камня и счетчик количества направлений от камня, в которых былла
    bool killedFlag = 0;
    QVector<int> indexes {1, -1, 0, 0, 0, 0, 1, -1, 21, -21, 1, -1};
    int killedDirections = 0;

    // Смотрим четыре стороны от камня - если хотя бы в одной из сторон при постановке данного камня оказывается, что
    // камень в этой стороне уходит в плен, то выставляем флаг для взятого в плен камня
    for (int i = 0; i < 4; i++)
    {
        int libertyCounter = 0;
        identifyGroup(array, positionX+indexes[i], positionY+indexes[i+4], index+indexes[i+8], array[positionX+indexes[i]][positionY+indexes[i+4]], libertyCounter);
        if (libertyCounter == 0 && currentGroup.size() == 1)
            killedFlag = 1;

        currentGroup.clear();
    }


    // Если хотя бы одна позиция справа, слева, сверху или снизу от камня свободна - значит,
    // камень можно поставить на доску, т.к. в такой ситуации ни правила ко, ни самоубийства
    // группы камней не происходит
    if (array[positionX+1][positionY] == -1 || array[positionX-1][positionY] == -1 ||
        array[positionX][positionY+1] == -1 || array[positionX][positionY-1] == -1)
        killedFlag = 0;

    return killedFlag;
}

// Функция актуализации положения камней на доске при каждом ходе
void GoBoard::makeRules(QList<QList<int>> array, const int &positionX, const int &positionY, const int & index, int color) {

    // Берём цвет текущего камня и актуальную позицию хода игрока
    currentColor = color;
    currentPosition = moves;

    // Если предполагаемый индекс позиции камня, начавшего ко-игру равен индексу текущего положения камня на доске и при этом
    // флаг для ситуации дамедзумари равен нулю (это значит, что предыдущим ходом была обработана
    // группа камней, состоящая из <= 1 камня, т.е. действительно была ко-игра), то в эту позицию камень не может быть поставлен,
    // снимаем его с доски и возвращаем ход игроку того же цвета обратно
    if (imaginaryKoIndex == index && damezumariFlag == 0) {
        emit deleteStone(index);
        emit getBackMove();
        return;
    }

    qDebug() << "is-nerstone:" << isNearStonesKilled(array, positionX, positionY, index, color);

    // Здесь мы обрабатываем ситуацию, когда при попытке поставить камень в самоубийственный пункт, получается "обмануть" систему
    // и при возврате управления тому же игроку получается сразу же отыграть обратно ко-игру. Это происходит из-за того, что
    // попытка хода в самоубийственный пункт хотя и отвергается программно, всё же является полноценным программным (!) ходом. Поэтому,
    // при попытке пойти в самоубийственный пункт, переменная suicideFlag становится равной единице и уже на следующем программном (!)
    // ходе (для игрока - его же текущем ходе), в совокупности с необходимыми условиями для обнаружения попытки отыграть ко-игру при
    // таком "обмане", мы отвергаем этот ход
    if (currentPosition - koPosition == 0 && suicideFlag == 1 && isNearStonesKilled(array, positionX, positionY, index, color) &&
        (qAbs(mindedIndex - index) == 21 || qAbs(mindedIndex - index) == 1))
    {
        emit deleteStone(index);
        emit getBackMove();

        return;
    }

    // Предполагаемый индекс позиции ко-игры здесь сбрасывается, т.к. проверку на ко-игру мы выполняем в самом начале функции
    imaginaryKoIndex = -10;

    // Проверяем 4 позиции (сверху, слева, снизу, справа) от поставленного на данном ходе камня для обнаружения возможных
    // убитых групп этим ходом
    checkNearestGroup(array, positionX+1, positionY, index+21, array[positionX+1][positionY]);
    checkNearestGroup(array, positionX-1, positionY, index-21, array[positionX-1][positionY]);
    checkNearestGroup(array, positionX, positionY+1, index+1,  array[positionX][positionY+1]);
    checkNearestGroup(array, positionX, positionY-1, index-1,  array[positionX][positionY-1]);

    // Теперь проверяем возможность постановки самого камня в данное положение на доске (возможно, что ход является самоубийственным)
    int libertyCounter = 0;
    identifyGroup(array, positionX, positionY, index, color, libertyCounter);
    currentGroup.clear();

    // Если количество дыханий у камня в данном положении на доске равно нулю, это значит, что либо ход является самоубийственным
    // и его постановку на доску нужно отвергнуть, либо ход является ко-атакой и её нужно обработать
    if (libertyCounter == 0) {

        // Если до этого были сняты камни с доски - это значит, что либо была взята в плен группа камней, либо один камень. Если была
        // взята в плен группа камней - до этого точно не было ко-игры, т.к. ко-игра возможна только с одним камнем.
        if (killedStoneFlag == 1) {

            // Обнуляем флаг, т.к. в противном случае, при безуспешной попытке отыграть ко, получится обойти проверку на ход в
            // самоубийственный пункт и группа, взятая в плен, не будет снята с доски
            killedStoneFlag = 0;

            // Если был взят в плен один камень - значит началась ко-игра. Запоминаем индекс камня, начавшего ко-игру и ход начала
            // ко-игры относительно игрока (реальный по счёту ход)
            if (oneStoneFlag == 1)
            {
                mindedIndex = index;
                koPosition = moves;
            }

            // Прерываем выполнение функции, чтобы проверка на попытку хода в самоубийственный пункт ниже ошибочно не сняла камень
            // с доски
            return;
        }

        // Здесь мы попадаем в ситуацию, когда поставленный камень оказывается в самоубийственном пункте, т.е. при таком ходе вся
        // группа целиком считается пленной. Т.к. правилами игры запрещено ходить в самоубийственные пункты, этот ход нужно отменить
        // и вернуть управление тому же игроку, что попытался походить в этот пункт
        emit deleteStone(index);
        emit getBackMove();

        // Выставляем флаг, сигнализирующий о попытке хода в самоубийственный пункт (это необходимо для корректной обработки ко-игры
        // в самом начале вызываемой функции) и прерываем выполнение функции, т.к. флаги после этой проверки обнуляются
        suicideFlag = 1;
        return;
    }

    // Обнуляем флаг попытки хода в самоубийственный пункт и флаг для предотвращения обхода ко-игры, счётчик реального хода игрока
    // увеличиваем на единицу
    suicideFlag = 0;
    killedStoneFlag = 0;
    moves += 1;
}
